#     mPython入门：

### 注释：

1. 注释：对程序进行标注和说明，增加程序的可读性。程序运行的时候会自动忽略注释。
2. 单行注释：使用`#`的形式。
3. 多行注释：使用`'''注释'''`的形式。

### 输入输出函数：

1. `input`函数：用来接收用户输入的数据。接收进来的数据都是字符串类型。
2. `print`函数：用来把数据打印到控制台的。更多的用法我们会在以后中介绍。

### 变量和基本数据类型：

1. 什么是变量：变量是一个容器，用来存储值的。
2. 如何定义变量。
3. 变量命名规则：
   - 大小写敏感：`hello`和`Hello`是两个不同名字的变量。
   - 驼峰命名：小驼峰`userAge`和大驼峰`UserAge`，一般类和模块的命名会使用大驼峰。
   - 下划线命名：`user_age`，一般模块和函数以及变量命名使用下划线。
   - 关键字：`and`、`or`、`def`、`class`、`import`、`print`、`return`等关键字不能作为变量名来使用。
4. `type`函数的使用：`type`函数用来获取变量的数据类型。比如`type(a)`。
5. 基本数据类型：
   - `int`类型：整形。
   - `float`类型：浮点类型。就是有小数点的数据。
   - `str`类型：字符串类型。

### 基本的数据类型转换：

1. 为什么需要做数据类型的转换。

2. 转换为整形：

   - 浮点类型转换为整形：

     ```
      a  = 4.567
      b = int(a)
      print(b)
     ```

     浮点类型转换成整形的规则是：保留小数点前面的数，去掉小数点和小数点后面的数。

   - 字符串转换为整形：

     ```
      a = '123'
      b = int(a)
      print(b)
     ```

     注意：字符串中必须全部都是阿拉伯数字，出现了非数字，就会报错。比如int('8.8')会报错。

3. 转换为字符串：使用`str`函数。

   - 整形转换为字符串。
   - 浮点类型转换字符串。

4. 转换为浮点类型：使用`float`函数。

   - 整形转换为浮点类型。
   - 字符串转换为浮点类型。

### 输出语句或函数：

1. 打印字符串和变量：

   - 打印普通的字符串：

   - 格式化输出：

     ```python
      # 整形：%d
      # 字符串类型：%s
      # 浮点类型： %f
     
      # 字符串变量类型的格式化
      name = 'zhiliao'
      print('my name is %s'%name)
     
      # 整形变量的格式化
      age = 2147483648
      print('my age is %d'%age)
     
      # 浮点类型变量的格式化
      price = 18.9
      print("apple's price is %f"%price)
      print("apple's price is %.2f"%price)
     ```

   - 打印多个变量：

     ```
      name = 'zhiliao'
      age = 18
      gender = 'boy'
      # 元组
      print('my name is %s,my age is %d,gender is %s'% (name,age,gender))
     ```

   - 其他打印方式：

     ```
      # 如果想字符串的末尾打印一个变量，那么可以采用以下方式
      age = 18
      print('my age is',age)
     
      # 如果是其他数据类型，使用%s的方式进行格式化
      # 那么其实，Python是首先将这个数据转换为字符串
      # 再进行格式化。
      age = 18
      print('my age is %s'%age)
      #知识拓展
      age =  25
     name = 'alix'
     weight = 142.5
     print('他的名字是%s他的年龄是%d他的体重是%f'%(name,age,weight))
     print(f"他的名字是{name}他的年龄是{age}他的体重是{weight}")
     print("他的名字是{}他的年龄是{}他的体重是{}".format(name,age,weight))
     
     
     ```

### 算数运算符：

1. `+`：加号运算符：

   ```
   a = 11
   b = 22
   c = a + b
   print(c)
   
   a = 'hello'
   b = 'world'
   c = a+b
   print(c)
   ```

2. `-`：减号运算符：

   ```
   a = 22
   b = 11
   c = a - b
   print(c)
   ```

3. `*`：乘号运算符。

   ```
   a = 2
   b = 3
   c = a * b
   print(c)
   
   c = 'hello'
   print '='*50
   print(c)
   print('='*50)
   ```

4. `/`：除法运算符：

   ```
   a = 5
   b = 2
   c = a / b
   print(c)   # 结果是2.5
   ```

5. `//`：取整除：

   ```
   a = 5
   b = 2
   c = a // b
   print(c)
   ```

6. `%`：取余：

   ```
   a = 5
   b = 2
   c = a % b
   print(c)
   ```

7. `**`：幂运算：

   ```
   # 1024K = 1M
   # 1024M = 1G
   # 1024G = 1T
   
   a = 2
   b = a ** 10
   print(b)
   ```

8. `+=`：`a+=1`等价于`a=a+1`。

9. `-=`：`a-=1`等价于`a=a-1`。

10. `*=`：`a*=2`等价于`a=a*2`。

11. `/=`：`a/=2`等价于`a=a/2`。

12. `%=`：`a%=2`等价于`a=a%2`。

13. `**=`：`a **= 2`等价于`a = a**2`。

14. `//=`：`a //= 2`等价于`a = a//2`。

# 分支语句

## if语句：

1. `bool`数据类型：真和假，只有两个值，就是`True`和`False`。

2. ```
   if
   ```

   语句使用的语法：

   ```
   if False:
       print('success')
   else:
       print('fail')
   ```

3. ```
   else
   ```

   ：语句：

   ```
   if False:
       print('success')
   else:
       print('fail')
   ```

4. 比较运算符：

   - ```
     a==b
     ```

     ：a和b是否相等.

     ```
         a = 1
         b = 2
         if a == b:
             print('equal')
         else:
             print('not equal')
     ```

   - ```
     a!=b
     ```

     ：a和b是否不相等.

     ```
         username = input(u'请输入用户名：')
         if username != 'zhiliao':
             print('您的用户是没有被加入到黑名单，可以正常使用')
         else:
             print('您的用户被加入到黑名单，不能正常使用')
     ```

   - ```
     a>b
     ```

     ：a是否大于b.

     ```
         age = 17
         if age > 17:
             print('您可以进入到网吧了')
         else:
             print('您年龄未满18岁，不能进入网吧')
     ```

   - ```
     a<b
     ```

     ：a是否小于b.

     ```
         age = 17
         if age < 18:
             print('您的年龄未满18岁，不能进入网吧')
         else:
             print('您可以进入到网吧了')
     ```

   - ```
     a>=b
     ```

     ：a是否大于等于b.

     ```
         age = 18
         if age >= 18:
             print('您可以进入到网吧了')
         else:
             print('您的年龄未满18岁，不能进入网吧')
     ```

   - ```
     a<=b
     ```

     ：a是否小于等于b.

     ```
         age = 18
         if age <= 17:
             print('您的年龄未满18岁，不能进入网吧')
         else:
             print('您可以进入到网吧了')
     ```

   - ```
     条件a and 条件b
     ```

     ：只有条件a和条件b都满足才成立:

     ```
         age = input('请您输入年龄：')
         age = int(age)
         if age >= 15 and age <= 24:
             print('您是一个青年人')
         else:
             print('您不是一个青年人')
     ```

   - ```
     条件a or 条件b
     ```

     ：只要条件a或者条件b中的一个满足，就成立：

     ```
         if age < 15 or age > 24:
             print('您不是一个青年人')
         else:
             print('您是一个青年人')
     ```

   - `not 条件a`：如果条件a为True，那么返回False。如果条件b为False，那么返回True:

     ```
         person1 = '中国人'
         person2 = '南非'
     
         if not person2 == '中国人':
             print('不可以上战舰')
         else:
             print('可以上战舰')
     ```

### elif语句：

```
   index = input('请输入星期数字：')

   index = int(index)

   if index == 0:
       print('星期天')
   elif index == 1:
       print('星期一')
   elif index == 2:
       print('星期二')
   elif index == 3:
       print('星期三')
   elif index == 4:
       print('星期四')
   elif index == 5:
       print('星期五')
   else:
       print('星期六')
```

# Python基础-循环

## 什么是循环：

循环是在满足特定条件的情况下，重复执行某段代码。

## while循环：

1. 示例：

   ```python
    num = 0
    while num < 10:
        print(num)
        num += 1
   ```

2. 案例1：猜数字游戏。

3. 案例2：求1-100整数之和。

4. 作业：打印九九乘法表。 

## break语句：跳出这个循环。

1. 示例：

   ```python
    num = 0
    while num < 10:
        if num == 5:
            break
        print(num)
        num += 1
   ```

2. 案例：猜数字游戏。

### continue语句：跳出当前这次循环。

1. 示例：

   ```python
    num = 0
    while num < 10:
        if num == 5:
            continue
        print(num)
        num += 1
   ```

2. 案例：打印10以内的所有的奇数。

### for循环：for循环可以遍历任何序列的对象，列表/字典/元组/字符串等。

1. 示例代码：

   ```python
    name = 'zhiliaoketang'
    for x in name:
        print(x)
   ```

2. 案例1：求1-10之间的和。

3. 案例2：统计'python papijiang papa mama'中p出现的个数。

4. 案例3：九九乘法表。

# 字符串：

### 什么是字符串：

1. 在Python中，使用单引号或者双引号括起来的，就是字符串。
2. 字符串也可以使用六个单引号或者六个双引号括起来。
3. 在`Python3`中，字符串分为两种类型，第一种是`str`，是`unicode`字符串，第二种是`bytes`，就是经过编码后的字符串，是一种字节码，适用于保存在磁盘上或者在网络上传输。

### 字符串拼接：

1. 使用加号的形式：

   ```python
    a = 'hello'
    b = 'world'
    c = a + b
    print(c)
   ```

2. 使用格式化的形式：

   ```python
    a = '___'
    b = 'abc'
    c = "%s%s%s" % (a,b,a)
   ```

### 字符串格式化：

字符串格式化，是将一个字符串中某些经常可能会改变的地方，提取出来，用一些占位符占位，后面再通过格式化的方式填充进去。格式化字符串有两种方式，第一种方式是使用`%s`的形式，第二种是使用`format`方法。下面依次来讲解一下：

#### 1. 使用%的形式：

```python
course = 'python'
school = 'zhiliao'
intro = "I love %s,I study in %s" % (course,school)
```

以上就是使用`%`的形式进行补充。当然针对不同的数据类型，应该使用不同的格式化：

1. 字符串：使用`%s`。
2. 整形：使用`%d`。
3. 浮点类型：使用`%f`。如果想要指定小数点后的位数。可以使用`%.nf`来表示，n为1表示一位小数，n为2表示2为小数，依次类推。

#### 2. 使用format函数的形式：

1. 使用位置参数占位符，示例代码如下：

   ```python
   greet = "I love {},I study in {}".format('python','zhiliao')
   ```

2. 使用关键字参数占位符，示例代码如下：

   ```python
   greet = "I love {arg1},I study in {arg2}".format(arg1='python',arg2='zhiliao')
   ```

### 字符串下标：

下标操作：字符串实际上就是跟一个容器一样，也可以跟列表和元组一样进行下标操作。
示例代码：

```python
    username = 'zhiliao'
    print(username[0])
    print(username[1])
    print(username[2])
    print(username[-1]) # 从后面开始
```

### 切片操作：

1. 起始位置：切片操作包括开始位置。负数从后面开始，最后一个元素是-1。
2. 结束位置：切片操作包括的是结束位置前面的一个元素。负数从后面开始，最后一个元素是-1。
3. 步长：代表每次取值的跨度。如果没有设置，默认为1。正数表示从左到右，负数表示从右到左。
4. 逆序：从后面往前开始走。所以起始位置应该是-1，然后要往前面走，那么应该指定步长为-1，然后要取到所有的值，那么结束位置应该留空。

### 字符串常见操作：

1. `find`：返回查找字符串的下标位置。如果返回的是-1，代表的是没有查找到该字符串。`rfind`是从右边到左边。
2. `index`：和`find`非常类似。只不过当查找不到这个字符串的时候，不是返回-1，而是抛出一个异常。`rindex`是从右边开始查找。
3. `len`：获取字符串字符的长度。
4. `count`：用来获取子字符串在原来字符串中出现的次数。
5. `replace`：新创建一个字符串，把原来字符串中的某个字符串替换为你想要的字符串。
6. `split`：按照给定的字符串进行分割。返回的是一个列表。
7. `startswith`：判断一个字符串是否以某个字符串开始。
8. `endswith`：判断一个字符串是否以某个字符串结束。
9. `lower`：将字符串全部改成小写。
10. `upper`：将字符串全部改成大写。
11. `strip`：将字符串左右的空格全部去掉。
12. `lstrip`：删除字符串左边的空格。
13. `rstrip`：删除字符串右边的空格。
14. `partition`：从`str`出现的第一个位置起，把字符串`string`分成一个3元素的元组`(string_pre_str,str,string_post_str)`，如果 string中不包含`str`，则`string_pre_str == string`。
15. `isalnum`：如果`string`至少有一个字符并且所有字符都是字母或数字则返回`True`，否则返回`False`。
16. `isalpha`：如果`string`至少有一个字符并且所有字符都是字母则返回`True`，否则返回`False`。
17. `isdigit`：如果`string`只包含数字则返回`True`否则返回 `False`。
18. `isspace`：如果字符串中只包含空格，则返回`True`，否则返回`False`。
19. `format`：格式化字符串。

### 转义字符：

| 转义字符 | 描述   |
| -------- | ------ |
| \在行尾  | 续行符 |
| \n       | 换行符 |
| \'       | 单引号 |
| \"       | 双引号 |
| \t       | 制表符 |
| \        | 反斜杠 |

### 原生字符串：

原始字符串不会对字符串中任何字符进行转义，你写了什么东西，这个字符串就是什么，达到一种所见即所得的效果。
语法：`r'xxx'`。

### 字符串编码和解码：

在`Python3`中，默认写的字符串都是`unicode`类型，`unicode`是一个万能的字符集，可以存储任意的字符，但是`unicode`字符串只能在内存中存在，不能在磁盘和网络间传输数据，如果要在文件或者网络间传输数据，必须要将`unicode`转换为`bytes`类型的字符串，因此我们在写代码的时候有时候要对`unicode`和`bytes`类型字符串进行转换，转换的函数如下：

1. `encode('utf-8')`：将`unicode`编码成`bytes`类型，并且编码方式采用的是`utf-8`。
2. `decode('utf-8')`：将`bytes`解码成`unicode`类型，并且解码的方式采用的是`utf-8`。
3. `utf-8`是编码的方式，还有其他编码方式，比如`gbk`、`ascii`等。

### Unicode字符串（选读）：

1. 什么是`unicode`字符串：因为历史原因，在`Python2`版本中，默认的字符串编码采用的是`ascii`编码（Python早于unicode发布）。而`ascii`编码是采用`1个字节`来存储，也就是`8位`，最多只能表示`2^8`也即`256`个字符，这在全世界远远是不够的，单拿中国汉字来讲，常用的汉字也有`6000`多个。因此，为了满足全球各个国家不同语言的编码需求，全球统一码联盟提出了`unicode`编码。`unicode`编码默认情况下会采用`2个字节`存储字符（UCS-2），这样能够存储的`2^16`也即`65536`个字符，但也还是不能满足全世界所有语言，因此后来又补充了用`4个字节`存储（UCS-4），这就可以包含全球所有的文字了。

2. ```
   unicode
   ```

   与其他编码的区别：

   - `unicode`是一个字符集，相当于一个字典，全世界所有的字符或者标点符号都对应一个数字。以后要在计算机中显示这个字符的时候，就使用`unicode`字符集中对应的那个数字就可以了。
   - `utf-8`、`gbk`、`latin-1`、`ascii`都是具体的编码实现。 因为`unicode`中，将大部分的字符都用2个字节存储，但是对于英文字母，比如`a`，其实他只需要一个字节就够了，如果都用2个字节存储，那么比较浪费硬盘空间或者浪费流量，因此`unicode`并不适合用来存储。而`utf-8`则是`unicode`的一种实现方式，他默认会使用`8`位，也就是一个字节存储，如果存储不下了，则会动态的改变大小用来存储字符。因此`utf-8`比较节省空间，并且也可以包含全世界所有的字符。

3. 在`Python2`中如何定义`unicode`字符串：在字符串的前面加上一个`u`，比如`u'中国'`。

4. `unicode`可以解决什么问题：在出现乱码或者编码错误的时候可以解决问题。

5. 如何将其他形式的编码字符串解码为

   ```
   unicode
   ```

   字符串：

   ```python
   greet = '你好'
   greet_unicode = greet.decode('utf-8')
   ```

6. 如何将

   ```
   unicode
   ```

   编码成其他编码字符串：

   ```python
   greet = u'你好'
   greet_utf8 = greet.encode('utf-8')
   ```

7. 之前看到的

   ```python
   import sys
   reload(sys)
   sys.setdefaultencoding('utf-8')
   ```

   的作用是什么：设置字符串在转换编码时候的默认编码。
   比如使用函数`unicode`将一个`str`字符串转换成`unicode`字符串，那么默认使用的就是`ascii`编码。如果你设置了以上的代码，那么将使用`utf-8`编码。

8. `#coding: utf-8`是用来干什么的：用来设置`Python`解释器在读取这个源代码文件时候使用的编码。在`python2`中默认使用`ascii`，所以需要改变一下文件的默认编码。而在`python3`中，默认使用了`utf-8`，则可以不要更改文件编码就可以支持中文了。

# Python基础-列表

### 为什么需要列表：

列表相当于一个容器。可以把一系列相关的值放在这个容器中进行存储。比如现在要存储水果的种类，那么如果通过之前的方式，一种水果用一个变量存储，那么代码将变得非常糟糕。正确的存储方式应该是定义一个列表类型的变量，然后把所有这些水果的名字存储到这个列表中。在其他编程语言中，叫做数组。

### 列表介绍：

1. 如何定义列表：使用左右两个中括号的形式。

   ```python
    fruits = ['apple','banana','orange']
    # 列表中的值，可以为不同的数据类型
    test_list = ['a',1]
   ```

2. 如何取列表中的值：列表支持下标操作，跟字符串的下标操作是一样的。

   ```python
    fruits = ['apple','banana','orange']
    a = fruits[0]
    b = fruits[1]
    c = fruits[2]
   ```

3. 列表的遍历：使用

   ```
   for
   ```

   和

   ```
   while
   ```

   循环都可以遍历。但一般推荐使用

   ```
   for
   ```

   循环。

   - ```
     for
     ```

     循环版本的：

     ```python
       fruits = ['apple','banana','orange']
       for fruit in fruits:
           print(fruit)
     ```

   - ```
     while
     ```

     循环版本的：

     ```python
       fruits = ['apple','banana','orange']
       index = 0
       length = len(fruits)
       while index < length:
           fruit = fruits[index]
           print(fruit)
     ```

4. 列表嵌套：列表中可以存储任何数据类型，当然也包括列表自身类型。也即，列表中也可以存储列表：

   ```python
    test_list = [1,2,3,['a','b','c']]
    for temp in test_list:
        print(temp)
   ```

5. 列表相加：列表相加，相当于把后面一个列表的数据追加到第一个列表后面。

   ```python
    a = [1,2,3]
    b = [4,5,6]
    c = a + b
    print(c)
   ```

6. 列表的切片操作：跟字符串中的切片操作是一样的。

   - 开始位置：包括开始位置。
   - 结束位置：会取到结束位置前一个元素。
   - 步长：默认位1，如果步长为负数，则从右到左。如果步长正数，则从左边到右边。
   - 切片可以赋值。
   - 逆序：list[-1::-1]

# 列表常用操作：

1. ```
   append
   ```

   ：在列表末尾添加元素。

   ```python
    fruits = ['apple']
    fruits.append('banana')
   ```

2. ```
   count
   ```

   ：统计某个元素在列表中出现的次数。

   ```python
    temps = ['to','be','or','not','to','be']
    print(temps.count('to'))
   ```

3. ```
   extend
   ```

   ：将一个列表中元素追加到另外一个列表中。

   ```python
    a = [1,2,3]
    b = [4,5,6]
    a.extend(b)
    # a的结果是：1,2,3,4,5,6
   ```

4. ```
   index
   ```

   ：找出列表中第一个某个值的第一个匹配项的索引位置，如果没有找到，则抛出一个异常：

   ```python
    knights = ['hello','world']
    print(knights.index('hello'))
   ```

5. ```
   insert
   ```

   ：将某个值插入到列表中的某个位置：

   ```python
    chars = ['hello','world']
    chars.insert(1,'nihao')
   ```

6. ```
   pop
   ```

   方法：移除列表中最后一个元素，并且返回该元素的值：

   ```python
    x = [1,2,3]
    temp = x.pop() # 返回3
   ```

7. ```
   remove
   ```

   方法：移除列表中第一个匹配的元素，不会返回这个被移除的元素的值。如果被移除的这个值不存在列表中，则会抛出一个异常。

   ```python
    x = [1,2,3]
    x.remove(2)
   ```

8. ```
   reverse
   ```

   ：将列表中的元素反向存储。会更改原来列表中的值。

   ```python
    x = [1,2,3]
    x.reverse()
    print(x) #这时候x已经变成3,2,1了
   ```

9. `sort`：将列表中的元素进行排序。会更改原来列表中的位置。

   ```python
    x = [4,2,1,5,3]
    x.sort()
    print(x)
   ```

   要区分`sorted`函数，`sorted`函数不会更改原来列表的位置，并且会返回一个排序后的值。

   ```python
    x = [4,2,1,5,3]
    y = sorted(x)
    print(y)
   ```

10. `del`关键字：根据下标删除元素：

    ```python
    a = [1,2,3]
    del a[0]
    print(a) # [2,3]
    ```

11. 使用`in`判断列表中是否有某个元素：

    ```python
    x = [1,2,3]
    if 1 in x:
        print(True)
    else:
        print(False)
    ```

12. `list`函数：将其他的数据类型转换成列表：

    ```python
    a = 'hello'
    print(list(a))
    ```

    # Python基础-元组

    ### 什么是元组：

    元组的使用与列表相似，不同之处在于元组是不可修改的，元组使用圆括号，而列表使用中括号。

    ### 定义元组：

    1. 使用逗号的方法：

       ```python
        aTuple = 1,2,3 #这样就定义好了一个元组
        print(aTuple)
       ```

    2. 使用圆括号的方法：

       ```python
        aTuple = (1,2,3)
        print(aTuple)
       ```

    3. 使用

       ```
       tuple
       ```

       函数：

       ```python
        aList = [1,2,3]
        aTuple = tuple(aList)
        print(aTuple)
       ```

    4. 定义只有一个元素的元组：

       ```python
        aTuple = 12, # 这样就定义号了只有一个元素的元组
        bTuple = (12,) #必须要再后面加一个逗号，否则就是一个普通的值了
       ```

    ### 元组常用操作：

    1. 下标操作：

       ```python
        aTuple = ('a','b','c')
        a = aTuple[0]
       ```

    2. 切片操作：跟列表和字符串的切片操作一样。

    3. 解组操作：

       ```python
        aTuple = ('zhiliao',18)
        name,age = aTuple
       ```

       或者有些时候我们只想要元组中的某个值，不需要所有的值，那么我们可以通过

       ```
       _
       ```

       来作为省略：

       ```python
        aTuple = ('zhiliao',18,'长沙')
        username,age,_ = aTuple
       ```

    4. `count`方法：获取元组中某个值出现的次数，跟列表中的用法相同。

    5. `index`方法：获取元组中某个值的下标，跟列表中的用法相同。

    ### 元组存在的意义或应用场景：

    1. 元组在字典中可以当作`key`来使用，而列表是不可以的。

    2. 在函数中，有时候要返回多个值，一般采用元组的方式。

    3. 在一些不希望用户修改值的场景下使用元组来代替列表。

       

# Python基础-字典

### 为什么需要字典：

有时候我们需要存储一组相关的数据的时候，比如要存储一个人的信息，那么有`username`，`age`，`birthday`等，如果这些信息都存储在列表中，或者数组中，比如`['username','age','birthday']`那么用起来可能不是很方便。比较方便的操作是，我直接通过`username`这个`key`就可以拿到这个值，我通过`username`就可以给这个`key`设置值，那么就可以通过字典的方式实现我们的需求。

### 字典基础：

1. 创建字典：我们可以通过两种方式创建字典：

   ```python
    person = {"username":"zhiliao","age":18}
   ```

   或者是使用`dict`函数：

   ```python
    person = dict(username='zhiliao',age=18)
   ```

2. 基本操作：

   - `len(d)`：返回字典的键值对的长度。
   - `d[k]`：获取`k`这个`key`对应的值。
   - `d[k] = v`：设置键为`k`的值为`v`，如果字典中不存在键为`k`的这一项，那么自动的添加进去。
   - `del d[k]`：删除`d`这个字典中键为`k`的这一项数据。
   - `k in d`：检查`d`这个字典中是否包含键为`k`的这一项。
   - 字典中的键可以是任意的不可变类型，比如：浮点类型、整形、字符串或者元组。

### 字典常用方法：

1. `clear`：清除字典中所有的项。

   ```python
    a = {'username':'zhiliao','age':18}
    print(a)
    a.clear()
    print(a)
   ```

2. `get`：访问字典中那个键对应的那个值。这个方法不会抛出异常。

   ```python
    a = {'username':'zhiliao','age':18}
    username = a.get('username')
    print(username)
    city = a.get('city') # 获取到的是一个None。
    # 也可以指定一个，在没有获取到这个值时候的默认值
    city = a.get('city','changsha') # 返changsha
    city = a['city'] # 抛出异常
   ```

3. `pop`：用来获得对应于给定键的值，然后将这个键盘和值的项从字典中删除。会返回这个值。

   ```python
    d = {'x':1,'y':2}
    d.pop('x')
   ```

4. `popitem`：随机的移除字典中的一项。因为字典是无序的，所以是随机的。

   ```python
    d = {'username':"zhiliao",'age':18}
    d.popitem() # 随机弹出一个值
   ```

5. `update`：用一个字典更新另外一个字典，如果碰到相同的键，则会覆盖。

   ```python
    a = {'url':'http://www.baidu.com/','title':"baidu"}
    b = {"url":"http://www.google.com/",'new_value':"new_value"}
    a.update(b)
    print(a)
   ```

6. `setdefault`：如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值，并且会设置值到字典中。

### 遍历字典：

1. 遍历字典中所有的`key`：使用`keys`方法，这个方法将所有的键以列表的方式返回。

   ```python
    a = {"url":"www.baidu.com",'title':"baidu"}
    for x in a.keys():
        print(x)
   ```

2. 遍历字典中所有的`value`：使用`values`方法，这个方法将所有的值以列表的方式返回。

   ```python
    a = {"url":"www.baidu.com",'title':"baidu"}
    for x in a.values():
        print(x)
   ```

3. 遍历字典中所有的键值对：使用`items`方法，这个方法将所有的键和值以列表的方式返回。

   ```python
    a = {"url":"www.baidu.com",'title':"baidu"}
    for key,value in a.items():
        print(key)
        print(value)
   ```



# Python基础-函数

### 为什么需要函数：

有时候，一些代码可能要在许多地方使用。如果采用传统的方式，一直重复编写相同的代码，那么代码将变得非常糟糕，并且非常难以维护。这时候我们就可以采用函数，来把一些重复执行的代码封装成一个函数，以后要再调用相同的代码的时候，就只要调用这个函数就可以了。

### 函数定义和调用：

1. 定义函数：语法是使用

   ```
   def
   ```

   ：

   ```python
    def 函数名(参数，可以为空):
        代码块
    # 示例：
    def greet():
        print('hello world')
   ```

2. 调用函数：语法是使用这个函数的名字，后面再给个圆括号：

   ```python
    函数名(参数，可以为空)
    # 示例：
    greet()
   ```

3. 函数参数：函数可以传递参数进去给函数：

   ```python
    def add(a,b):
        print(a+b)
   ```

   - 形参：就是在定义函数的时候指定的参数。

   - 实参：就是在调用函数的时候传递进去的参数。

   - 位置参数：位置参数就是按照形参中给定的参数的顺序。

     ```python
      def add(a,b):
          print(a+b)
      # 调用add
      add(1,2)
     ```

     在上例中，调用add函数，给的值a为1，b为2。这种位置很重要的参数叫做位置参数。

   - 关键字参数：在传递参数的时候，可以按照形参的名字给定参数。

     ```python
      def add(a,b):
          print(a + b)
      # 调用add
      add(a=1,b=2)
      # 调换a和b参数的顺序来调用add函数
      add(b=1,a=2)
     ```

   - *args和**kwargs：分别代表的是缺省的位置参数和关键字参数。

     ```python
        def add(*args,**kwargs):
            print(args)
            print(kwargs)
        # 调用add
        add(1,2,a=3,b=4)
     ```

     其中1和2是位置参数，会保存在`args`中，a=3,b=4是位置参数，保存在`kwargs`中。
     传递到函数中的args是一个元组，kwargs是一个字典。

   - 元组和字典拆分出来成位置参数和关键字参数：

     ```python
      a = ('a','b','c')
      b = {"username":"zhiliao","age":18}
      def greet(*args,**kwargs):
          print(args)
          print(kwargs)
      greet(*a,**b) # 将a这个元组个的元素一个个拆开来给`args`，将`b`拆开来一个个给`kwargs`
     ```

   - 默认参数：有时候一些参数，你可能需要给函数调用者，使用一个默认的参数，那么可以通过以下方式实现：

     ```python
       def greet(name,age=18):
           print(name,age)
       greet('zhiliao') #age将使用18来作为默认参数
       greet('zhiliao',age=20) #age将使用20来作为默认参数
     ```

     默认参数一定要放在其他参数的后面，但是放在缺省参数的前面。

4. 函数返回值：函数可以有返回值：

   ```python
    def add(a,b):
        return a + b
   ```

   可以使用元组来返回多个值：

   ```python
    def greet():
        return 'zhiliao',18
   ```

### 函数中变量的作用域：

1. 局部变量：函数中的变量，不能在外面使用。

   ```python
    def greet():
        name = 'zhiliao'
        print('my name is %s'%name)
    print(name) # 报错，因为name只在greet函数中有用
   ```

2. 全局变量：全局变量是在函数或者某个代码块外面定义的变量，可以在函数中进行使用。

   ```python
    username = 'zhiliao'
    def greet():
        print('my name is %s' % username)
    greet()
   ```

3. ```
   global
   ```

   关键字：如果想在函数或者某个代码块中修改全局变量，那么应该使用

   ```
   global
   ```

   关键字。

   ```python
    username = 'zhiliao'
    def greet():
        username = 'ketang' # 此时不是修改全局变量username，而是定义一个与全局变量相同名字的变量
        print('my name is %s' % username)
    greet()
    print(usernmae) # 这时候username仍然是`zhiliao`。
   ```

4. 列表和字典当作全局变量：列表和字典当作全局变量，在函数或者代码块中使用的时候，可以任意的增删改查列表和字典的值。但是如果要修改这个全局变量指向的值，则必须加`global`关键字。

   ```python
    persons = ['zhangsan','lisi']
    def add_person(name):
        persons.append(name)
    add_person('wangwu')
    print(persons) # 这时候persons已经变成['zhangsan','lisi','wangwu']了。
   ```

   而如果你直接修改persons的指向，但没有使用`global`关键字，那么做的操作，将是在本地申请一个局部变量：

   ```python
    persons = ['zhangsan','lisi']
    def add_person():
        persons = ['wangwu']
    add_person()
    print(persons) # 仍然是'zhangsan'和`lisi`
   ```

### 匿名函数：

1. 列表排序`sort`：使用`sort`给列表中的值进行排序的时候。如果列表中装的是字典，那么将不能正确的排序：

   ```python
    l = [{'username':'zhangsan','age':18},{"username":'lisi','age':20}]
    l.sort()
   ```

   正确的写法应该是：

   ```python
    l = [{'username':'zhangsan','age':18},{"username":'lisi','age':20}]
    def sort_key(x):
        return x['age'] # 根据年龄进行排序
    l.sort(key=sort_key)
   ```

2. 以上是定义一个函数来作为`key`，但是这个`key`的函数只需要用一次，以后再也用不到了，因此一般这种情况，我们可以使用匿名函数，也即`lambda`表达式，可以更好的完成我们的需求：

   ```python
    l = [{'username':'zhangsan','age':18},{"username":'lisi','age':20}]
    l.sort(key=lambda x:x['age'])
   ```

3. 自己动手写一个需要函数作为参数的函数：我们可以模范`python`自带的`sort`函数来实现一个做计算器运算的函数，我们让用户输入值，和计算方式：

   ```python
    def calculate(x,y,func):
        return func(x,y)
   
    # 实现一个加法计算器
    calculate(1,2,lambda x,y:x+y)
    # 实现一个减法计算器
    calculate(2,1,lambda x,y:x-y)
    # 实现一个乘法计算器
    calculate(1,2,lambda x,y:x*y)
    # 实现一个除法计算器
    calculate(4,2,lambda x,y:x/y)
   ```

# Python基础-文件操作

### 打开和关闭文件：

1. 打开文件：

   ```python
    f = open('xxx.txt','w') #以写的方式打开一个文件
   ```

2. 关闭文件：

   ```python
    f = open('xxx.txt','w')
    f.close() #关闭文件
   ```

### 文件的打开模式：

| 打开模式        | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| r(read)         | 以只读的方式打开。文件的指针将会放在文件的开头。这是默认的模式 |
| w(write)        | 以只写的方式。如果该文件已经存在则将其覆盖。如果不存在，则创建一个文件用于写入。 |
| a(append)       | 以追加的方式打开文件。如果该文件存在将新的内容追加到文件末尾。如果不存在，则创建新文件用于写入。 |
| rb(read binary) | 以二进制的并且只读的方式打开一个文件。文件指针将会放在文件的开头。 |
| wb              | 以二进制和只写的方式打开一个文件。如果该文件已经存在则将其覆盖。如果该文件不存在，则创建新文件用于写入。 |
| ab              | 以二进制和追加的方式打开一个文件。如果该文件已经存在则追加到文件末。如果不存在，则创建新文件用于写入。 |
| r+              | 打开一个文件用于读写。文件指针将会放在文件的开头。写进去的内容会覆盖原来的内容。 |
| w+              | 打开一个文件用于读写。如果该文件已经存在则将其覆盖。如果文件不存在，则创建新文件。 |
| a+              | 打开一个文件用于读写，文件指针将会放在文件的结尾。如果文件存在，则会将新内容追加到文件后面。如果文件不存在，则创建新文件。 |
| rb+             | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 |
| wb+             | 以二进制格式打开一个文件用于读写。如果该文件已经存在则将其覆盖。如果文件不存在，创建新文件。 |
| ab+             | 以二进制格式打开一个文件用于追加。如果该文件已经存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |

### 文件的读写操作：

1. 读数据：使用read(count)函数可以从文件中读取数据，count表示要从文件中读取的数据的长度。如果没有传，那么表示读取文件中的所有的数据。

   ```python
    fp = open('test.txt','r')
    # 读取前面5个字节的数据
    line = fp.read(5)
    print(line)
    # 读取所有的数据
    line = fp.read()
    print(line)
   ```

2. 读一行的数据：使用

   ```
   readline
   ```

   可以以行的形式读取文件。

   ```python
    fp = open('test.txt','r')
    line = fp.readline()
    print('第一行：%s' % line)
    line = fp.readline()
    print('第二行：%s' % line)
    fp.close()
   ```

3. 以行的形式把文件中所有的数据都读出来：

   ```
   readlines
   ```

   返回一个列表，列表中装的就是文件中每行的数据。

   ```python
    fp = open('test.txt','r')
    lines = fp.readlines()
    for line in lines:
        print(line)
    fp.close()
   ```

4. 直接迭代文件对象：文件对象也是一个迭代器。即可以通过

   ```
   for
   ```

   循环来进行迭代，并且一次性只会读取一行，从而可以读取大文件。

   ```python
    fp = open('test.txt','r')
    for line in fp:
        print(line)
   ```

5. ```
   write
   ```

   写数据到文件中：

   ```
   write
   ```

   将数据写入到文件中。

   ```python
   fp = open('test.txt','w')
   fp.write('hello')
   fp.close()
   ```

6. ```
   writelines
   ```

   写多个数据到文件中：

   ```
   writelines
   ```

   可以一次性写入多个数据，但是不会自动换行。

   ```python
   fp = open('test.txt','w')
   fp.writelines(['hello','world'])
   fp.close()
   ```

### 文件的定位读写：

1. 获取当前文件指针的位置：在读写的过程中，如果想要知道当前文件指针所在的位置，可以通过`tell()`来获取。

   ```python
    fp = open('xxx.txt','r')
    str = fp.read(3)
    print('读取到的数据是：%s' % str)
   
    # 查看当前位置
    position = fp.tell()
    print("当前文件位置：%d" % position)
   
    fp.close()
   ```

2. 定位到某个位置：如果在读写文件的过程中，需要从另外一个位置进行操作，可以使用`seek()`。`seek(offset,from)`有2个参数，意义为如下：

   - offset：偏移量。
   - from：相对位置。
     - 0：表示从文件开头。
     - 1：表示从当前位置。
     - 2：表示从文件末尾。

   **但是在Python3中，如果from的值不是等于0，那么offset就必须为0。**

   ```python
   # demo1：把相对位置设置为从文件开头，并且向后偏移5个字节。
   fp = open("xxx.txt","r")
   position = fp.tell()
   print("当前文件指针位置是：%d" % position)
   fp.seek(5,0)
   position = fp.tell()
   print('当前位置是：%d' % position)
   str = fp.read()
   print('读取到的字符串：%s' % str)
   ```

   ```python
   # demo2：把位置设置为：离文件末尾，3个字节处
   fp = open("xxx.txt","r")
   # 查看当前位置
   pos = fp.tell()
   print('当前文件指针位置：%d' % pos)
   # 重新设置位置为离文件末尾3个字节位置，会报错
   # fp.seek(-3,2)
   fp.seek(0,2)
   fp.seek(fp.tell()-3,0)
   # 读取数据
   str = fp.read()
   # 关闭文件
   fp.close()
   ```

### 关闭文件：

通常来说，一个文件对象在退出程序后会自动关闭。但是对于一些你写入了数据的文件，应该手动的进行关闭。因为Python可能会缓存写入的输入，如果程序抛出异常，那么缓存的文件将不会被写入文件。因此为了安全起见，要在使用完文件后关闭。
一般的写法是：

```python
    fp = open("xxx.txt",'r')
    try:
        # your code
    finally:
        # 为了安全起见，不管程序有没有发生异常，都要关闭文件
        fp.close()
```

实际上，有专门为这种情况设计的语句，即`with`语句：

```python
    with open('xxx.txt','r') as fp:
        # your code
```

以上的`with`语句，不管程序有没有发生异常，都会关闭文件。`with`语句是叫做上下文管理器，上下文管理器是一种支持`__enter__`和`__exit__`这两个方法的对象。后期会讲到。以后在使用文件操作的时候，应该尽量使用`with`语句。

### 案例：

1. 拷贝文件。
2. 把有病毒的文件修改为正常的代码。

# Python基础-面向对象

### 什么是面向对象：

面向对象是现代语言必备的一个特性。传统的面向过程编程（模块封装都是通过函数实现的，类似于C语言），不符合人类思考的一种方式。比如人吃饭这种行为，如果使用面向过程编程，那么是首先定义一个吃饭的行为，然后再把这个人传过去。这明显是不符合人类的思考方式的，人类正常的思考方式应该是，吃饭这个行为是属于人类的，应该由人的这个对象自己去执行。这种思考方式的转变，就是面向对象。面向对象把所有属于某种物体（比如人）的属性和行为全都定义在这个物体上，比如年龄，身高，体重这些是属性，比如招手，跑步，吃饭这些是行为。以后要知道一个人的年龄，应该查看这个人的年龄属性，要让这个人奔跑，应该调用这个人的奔跑方法。这种思考方式就是面向对象。

### 类和对象：

1. 类：是对某种物种的一种抽象表达。比如人类，人类是我们对人的一种抽象，他有年龄属性，身高属性，奔跑，吃饭等行为。
2. 对象：对象是对类的一种具体化。比如具体的某个人，他是属于人类这个类的，但他是个确确实实存在的实体。总结就是，对象是类的一种具体实现。

### 类和对象的使用：

1. 类：定义一个类的语法是使用

   ```
   class
   ```

   关键字，开发者自己定义的类，必须继承自

   ```
   object
   ```

   类，

   ```
   object
   ```

   类是

   ```
   Python
   ```

   中所有的类的基类。类中所有的方法都要以

   ```
   self
   ```

   作为第一个参数传递进去，这是规定。

   ```
   self
   ```

   代表的是当前的对象。

   ```python
    class Person(object):
        def eat(self):
            print('吃饭')
   ```

2. 对象：对象是对类的一个实例化，对象的创建方式如下（比如要实现一个Person的对象）：

   ```python
    person1 = Person()
    person1.eat()
   ```

### 构造函数和实例属性：

构造函数是Python类在初始化对象的时候会调用的方法。一般在这个方法中给一些属性进行初始化。一般就是用来初始化实例属性的：

```python
    class Person(object):
        def __init__(self,name,age):
            self.name = name
            self.age = age

    person1 = Person('zhiliao',18)
    print(person1)
```

给对象添加实例属性非常简单，以上是通过`self.name`的方式实现的，其实也可以通过以下方式实现，原理都是一样的。

```python
    class Person(object):
        pass
    person1 = Person()
    # 给person1这个对象绑定name属性
    person1.name = 'zhiliao'
```

### 访问限制：

1. 受保护的属性和方法：有时候在类中的属性或者是方法不想被外界调用，但还是可以被外界所调用，那么就叫做受保护的属性或者方法。受保护的属性或者方法，使用一个下划线开头：

   ```python
    class Person(object):
        def __init__(self):
            self._age = 19
   
    p1 = Person()
    # 以下代码可以打印出_age，但这样做是违背开发者意愿的。
    print(p1._age)
   ```

2. 私有属性和方法：有时候在类中的属性或者方向不让外界调用，那么就可以使用定义成私有属性或者私有方法。私有属性或者方法使用两个下划线开头：

   ```python
    class Person(object):
        def __init__(self):
            self.__age = 19
   
    p1 = Person()
    # 以下代码将报错
    print(p1.__age)
   ```

3. 更多：

   - 私有方法或者属性不是说100%不能访问，以上方式，可以通过`_Person__age`来访问，但这样做是不推荐的。
   - `__init__`这些方法不是私有方法，是特殊变量或方法。

### 析构函数和引用计数：

1. `Python`中的类也有析构函数，也即`__del__`方法，只要这个对象在内存中即将被消灭的时候，就会调用这个方法。

   ```python
    class Person(object):
        def __del__(self):
            print('我即将被消灭了~')
   
    p1 = Person()
    # 调用完这个代码后，就会去执行Person类中的__del__方法
    del p1
   ```

2. 引用计数：`Python`中的对象是使用引用计数的方式实现的。也即如果没有任何对象引用到一块内存，那么`Python`将会把这块内存回收。看以下代码：

   ```python
    class Person(object):
        def __del__(self):
            print('我即将被消灭了~')
   
    p1 = Person()
    p2 = p1
    del p1
    # 先会打印=====
    print('======')
    # 再会去执行__del__方法
   ```

   可以使用`sys.getrefcount(object)`来获取一个对象的引用计数。

### 继承：

继承可以使用其他类当作自己的父类，那么父类中的方法和公有属性都可以被子类使用。继承的好处是可以让子类节省代码，实现更多的功能。

```python
    class Person(object):
        def eat(self):
            print('在吃东西')

        def run(self):
            print('奔跑中')


    class Student(Person):
        pass
以上`Student`这个类没有写任何方法，但是也能拥有父类`Person`这个类的`eat`和`run`方法。
```

### 重写父类的方法：

有些时候，父类中的方法不一定适合子类，那么这时候可以重写父类的方法，而使用子类自己定义的方法。

```python
    class Person(object):
        def eat(self):
            print('在吃东西')

        def run(self):
            print('奔跑中')


    class Student(Person):
        def eat(self):
            print('吃食堂大锅菜')
```

有时候想使用父类的方法，但是父类中的方法不完全满足我们的需求，那么就可以在子类的同名方法中使用`super`关键字调用父类的方法，然后再在子类中实现自己的需求：

```
​```python
class Person(object):
    def eat(self):
        print('在吃东西')

class Student(Person):
    def eat(self):
        super(Student,self).eat()
        print('这是学生的吃饭方法')
​```
```

以上在`Student`中的`eat`方法中，首先会调用父类`Person`的`eat`方法，然后再执行子类自己的代码。

### 私有属性和方法在子类中的使用：

在类继承中，私有属性和方法是不能被子类继承的：

```python
    class Person(object):
        def __greet(self):
            print('helo')

    class Student(Person):
        def greet(self):
            self.__greet()

    s1 = Student()
    # 以下代码将报错，因为子类不能继承父类的方法
    s1.greet()
```

### 新式类和旧式类：

在`Python2.2`中，新增了一种新式类，新式类的出现，让类更加规范，并且也给类默认添加了许多的功能，比如`property`等。在`Python2`中，如果想要定义新式类，必须手动的写明继承父类为`object`。而在`Python3`中，定义类，默认使用的就是新式类，不需要再写明父类为`object`。

```python
# 新式类：
class Person(object):
    def show(self):
        print('hello world')

# 旧式类：
class Person:
    def show(self):
        print('hello world')

# 如何查看一个类式新式类还是旧式类：
# * 如果以下打印出来的是type，那么是新式类
# * 如果以下打印出来的是classobj，那么是旧式类
print(type(Person))
```

旧式类不能使用`super`关键字来调用父类的方法，只能通过父类名调用父类的方法：

```python
    class Person:
        def __init__(self,name):
            self.name = name

    class Student(Person):
        def __init__(self,name):
            Person.__init__(self,name)

    s = Student('zhiliao')
    print(s.name)
```

### 多继承及其注意事项：

在`Python`的面向对象编程中，是支持多继承的，也即一个类可以继承自多个父类。

```python
    class Ma(object):
        def qima(self):
            print('骑马')

        class Lv(object):
            def lamo(self):
                print('拉磨')

        class Luozi(Ma,Lv):
            pass
```

以上骡子类`Luozi`没有写任何方法，但是可以继承`qima`和`lamo`两种操作。但是在多继承中也有需要注意的地方，就是会出现另行的情况，比如以下类：

```python
class Animal(object):
    def eat(self):
        print('动物吃东西')

class Ma(Animal):

    def qima(self):
        print('骑马')

    def eat(self):
        print('马吃草')
        super(Ma,self).eat()
        print('马吃完了草')

class Lv(Animal):
    def lamo(self):
        print('驴拉磨')

    def eat(self):
        print('驴吃麦子皮')
        super(Lv,self).eat()
        print('驴吃完了麦子皮')

class Luozi(Ma,Lv):

    def eat(self):
        super(Luozi,self).eat()
        print('骡子既吃草又吃麦子皮')


luozi = Luozi()
luozi.eat()
print(Luozi.__mro__)
```

在新式类中，如果多继承，那么将采用`C3算法`，使用的是广度优先的算法，打印`Class.__mro__`可以看到基类执行的顺序。 在旧式类中，如果多继承，那么将采用深度优先的算法。

### 多态：

面向对象有三大特性，分别为：封装/继承/多态。多态的意思是，不同的对象，都实现了同一个接口，因此我们可以不管这个对象是什么，直接调用这个方法旧可以了。
比如王者荣耀中的英雄，每个人都有三个技能，但每个英雄的具体实现是不一样的。如果用代码来表示，那么可以用以下方式表示：

```python
class Hero(object):
    def stroke(self):
        pass

class Chengyaojin(Hero):
    def stroke(self):
        print('回血加攻击速度和攻击力')

class Xiangyu(Hero):
    def stroke(self):
        print('推人')

hero_index = input('请输入英雄：')
hero = None
if hero_index == '1':
    hero = Chengyaojin()
elif hero_index == '2':
    hero = Xiangyu()
else:
    hero = Hero()

skill_index = input('请输入技能：')
if skill_index == '3':
    hero.stroke()
```

### 类属性和实例属性：

1. 类属性：这个属性属于类的，所有对象都可以访问。
2. 实例属性：这个属性是属于对象的，只有这一个对象可以访问和使用，其他对象不能使用。
3. 注意事项：对象可以访问类属性，但是如果想要修改类属性，则必须通过类名进行修改！

### 类方法和静态方法：

1. 类方法：类方法是属于这个类的，可以通过这个类对象调用，也可以通过这个类的实例对象调用。

2. 静态方法：静态方法是属于类的，只能通过类名字调用。静态方法中不能调用类属性，如果要调用，只能通过类名来调用。并且不需要传任何参数。

   ```python
   class Person(object):
        country = 'china'
   
        @classmethod
        def show(cls):
            print('i am from %s' % cls.country)
   
        @staticmethod
        def show():
            print('i am from %s' % Person.country)
   ```

### 使用面向对象的方法组装一台电脑：

电脑由以下几部分组成：CPU、内存条、硬盘等。每个部分都定义成一个类，最后组装成一台电脑，让他跑起来。示例代码如下：

```python
class CPU(object):

    def __init__(self,brand,core,ghz,interface):
        self.brand = brand
        self.core = core
        self.ghz = ghz
        self.interface = interface

    def run(self):
        print('{}牌子，核心数为{}跑起来了'.format(self.brand,self.core))

class RAM(object):

    def __init__(self,brand,size):
        self.brand = brand
        self.size = size

    def run(self):
        print('{}牌子，尺寸为{}的内存跑起来了'.format(self.brand,self.size))


class Disk(object):

    def __init__(self,brand,size):
        self.brand = brand
        self.size = size

    def run(self):
        print("{}牌子，大小为{}的硬盘跑起来了".format(self.brand,self.size))

class Computer(object):

    def __init__(self,cpu_interface,max_ram,max_disk):
        self.cpu_interface = cpu_interface
        self.max_ram = max_ram
        self.max_disk = max_disk
        self.cpu = None
        self.rams = []
        self.disks = []

    def add_cpu(self,cpu):
        if self.cpu:
            print('该主板已经有CPU了！')
            return False
        if cpu.interface != self.cpu_interface:
            print('该主板的CPU接口与此CPU接口不一致！')
            return False

        self.cpu = cpu

    def add_ram(self,ram):
        if len(self.rams) == self.max_ram:
            print('该主板能容纳内存条已达到上限，不能再添加！')
            return

        self.rams.append(ram)

    def add_disk(self,disk):
        if len(self.disks) == self.max_disk:
            print('该主板能容纳硬盘数量已达上线，不能在添加！')

    def run(self):
        print('通电了...')
        # 1. cpu先跑起来
        if self.cpu:
            self.cpu.run()
        else:
            print('没有CPU，不能跑起来')
            return

        # 2. 内存跑起来
        if len(self.rams) > 0:
            for ram in self.rams:
                ram.run()
        else:
            print('没有内存条，不能跑起来')
            return

        # 3. 硬盘爬起来
        if len(self.disks) == 0:
            for disk in self.disks:
                disk.run()
        else:
            print('没有硬盘，电脑不能跑起来')
            return

        print('电脑跑起来了，你可以上知了课堂学习Python了！')


def main():
    cpu = CPU(brand='intel',ghz=2.7,core=4,interface='11211')
    ram1 = RAM(brand='金士顿',size=4)
    ram2 = RAM(brand='金士顿',size=4)
    disk = Disk(brand='tongchi',size=256)

    computer = Computer(cpu_interface='11211',max_ram=2,max_disk=2)
    computer.add_cpu(cpu)
    computer.add_ram(ram1)
    computer.add_ram(ram2)
    computer.add_disk(disk)

    computer.run()

if __name__ = '__main__':
    main()
```

# Python基础-面向对象（2）

### `__new__`函数：

`__new__`方法是用来控制这个类创建对象的执行逻辑。这个方法是在对象还没有创建之前就会执行的。而`__init__`方法是在对象创建完毕后才执行。比如看下以下代码的执行顺序：

```python
class Person(object):
    # __new__方法的参数不是self，而是cls，代表当前这个类
    def __new__(cls,*args,**kwargs):
        print('new方法执行')
        # 一定要返回对象，不然就不会创建对象
        # object的__new__不接收参数，因此__new__方法不能传入*args和**kwargs参数
        return super(Person,cls).__new__(cls)

    # __init__方法是在对象被创建完毕后进行一些初始化的
    # 因此这时候是self，因为这个对象已经存在了
    def __init__(self):
        print('init方法执行')

    # __del__方法是在这个对象被销毁的时候调用的
    def __del__(self):
        print('del方法执行')

p = Person()
# 打印顺序
# 1. new方法执行
# 2. init方法执行
# 3. del方法执行
```

### Python创建单例对象：

单例的意思是：在程序中，某个类的对象只有一个。这种需求其实很常见，比如一个项目中有一个配置文件，那么可以通过定义一个`Config`的类来操作配置信息，但是配置信息在整个项目中其实只需要一份就够了，这时候就可以使用到单例模式了。

```python
# 单例模式
class Person(object):

    __instance = None

    def __new__(cls,*args,**kwargs):
        if not cls.__instance:
            cls.__instance = super(Person,cls).__new__(cls)
        return cls.__instance

p1 = Person()
p2 = Person()
print(id(p1))
print(id(p2))
```

# Python基础-异常处理

## 程序开发中为什么需要异常处理：

有些时候我们的程序在运行过程中可能会有意想不到的事情发生，这种情况就叫做异常，异常如果不处理好，可能直接导致我们的程序退出崩溃。因此我们要对异常进行处理，来确保我们的程序能够稳健的运行。

## 异常处理的语法：

```python
try:
    # 你感觉可能会崩溃的代码
except 异常名字：
    # try语句出现异常的时候执行的代码
else:
    # try语句中没有抛出异常的时候执行的代码
finally:
    # 不管程序有没有抛出异常，都会执行的代码
```

示例：

```python
try:
    a = 1
    b = 0
    c = a/b

    print(c)
except ZeroDivisionError:
    print('try中的代码如果抛出异常，会执行这里的代码')
else:
    print('try中的代码如果没有抛出异常，会执行这里的代码')
finally:
    print('不管try中的代码有没有抛出异常，都会执行这里的代码')
```

## 使用多个`except`来捕获多个异常：

```python
    try:
        # a = 1
        # b = 0
        # c = a/b

        print(c)
    except ZeroDivisionError:
        print('这个except语句只会捕获ZeroDivisionError异常')
    except NameError:
    pritn('这个except语句只会捕获NameError异常')
```

## 如果想要将多个异常放在一个`except`中捕获，那么可以使用元组的形式：

```python
    try:
        # a = 1
        # b = 0
        # c = a/b

        print(c)
    except (ZeroDivisionError,NameError):
        print('这个except语句会捕获ZeroDivisionError和NameError异常')
```

## 如果你不知道具体会抛出什么异常，那么你可以使用Exception来接收所有的异常，示例代码如下：

```python
    try:
        a = 1
        b = 0
        c = a/b

        print(c)
    except Exception as error:
        print('不管抛出了什么异常，都会执行这里的代码')
        print(error)
```

上例中也用到了`as`关键字，将捕获到的错误赋值给`error`这个变量，那么你就可以通过这个变量知道这是什么错误了。

## 抛出异常：

有时候你觉得这个地方如果出现了不该出现的，或者没有按照你的想法执行，那么你可以抛出一个异常：

```python
    def greet(name,age):
        if type(name) != str:
            raise ValueError('name必须为str类型')
        if type(age) != int:
            raise ValueError('age必须为int类型')

    try:
        greet('zhiliao','18')
    except ValueError as error:
        print(error.args)
```

## 自定义异常：

自定义异常需要继承自`Exception`类：

```python
class ArgumentError(Exception):
    def __init__(self,*args,**kwargs):
        super(ArgumentError,self).__init__(*args,**kwargs)
        # self.args = args
        print('参数错误')


def greet(name,age):
    if type(name) != str or type(age) != int:
        raise ArgumentError('参数类型错误')
    print('my name is:%s，my age is:%s' % (name,age))


try:
    greet('zhiliao','18')
    raise ArgumentError('name必须为str类型')
except Exception as error:
    print(error.args)
```

## 常见异常：

| 异常名称            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| AttributeError      | 属性错误，访问一个对象的不存在的属性的时候，抛出这个异常     |
| ImportError         | 导入包错误                                                   |
| IndexError          | 下标错误，一般有列表越界等                                   |
| KeyError            | key错误，一般访问字典的key不存在的时候                       |
| NameError           | 变量名不存在                                                 |
| NotImplementedError | 某个方法没有实现的错误                                       |
| StopIteration       | 迭代器已经到最后了                                           |
| IndentationError    | 缩进错误                                                     |
| TabError            | 包含了tab和空格错误                                          |
| TypeError           | 类型错误，有时候传递了一个错误类型的值给其他函数             |
| UnicodeEncodeError  | Unicode编码错误，一般是unicode->str错误                      |
| UnicodeDecodeError  | Unicode解码错误，一般是str->unicode错误                      |
| ValueError          | 值错误，比如传一个12a给int()函数转换                         |
| ZeroDivisionError   | 除0错误                                                      |
| IOError             | 打开一个不存在的文件（在Python3中使用FileNotFoundError）     |
| FileNotFoundError   | 文件没有找到的错误                                           |
| 更多请参考：        | https://docs.python.org/3/library/exceptions.html#concrete-exceptions |

# python基础-模块和包：

### 为什么需要模块和包：

随着项目越来越大，所有代码都放在一个文件中，已经不能满足我们的需求了。这时候就要将代码进行整理了，模块和包的出现就是为了解决这个问题的。模块可以将一些相关联的代码组合在一个`py`文件中，包可以将一些相关联的模块组合在一个文件夹中。

### 将一个模块导入到当前文件中的几种方式：

1. `import`：导入某个模块。以后要使用模块中的函数或者方法或者变量，则需要使用`模块名.xxx`的形式调用。
2. `from xxx import xxx`：从某个模块中导入某个对象或者方法等。也可以一次性的从模块中导入所有的对象。使用`from xxx import *`。
3. `from a import b as c`：从`a`中导入`b`并命名为`c`。以后在代码中引用`b`，通过`c`来引用。

### 包：

包其实本质上就是一个文件夹，将一些相关联的模块组合在一起。但是如果一个文件夹要让`Python`识别为一个包，则必须在这个文件夹中创建一个叫做`__init__.py`的文件。一个文件夹中只有拥有了`__init__.py`这个文件，才能被视为一个包。
在同一个包中的模块如果要互相导入，则只能通过相对的方式进行导入，即：`from . import xxx`。

### `__all__`：

1. 如果是在模块中写了这个变量，将控制`from 模块名字 import *`的行为。
2. 如果在`__init__.py`文件中有这个变量，那么它将控制着`from 包 import *`的行为。

### 模块的搜索路径：

1. 在当前目录下搜索模块。
2. 在环境变量`PYTHONPATH`中搜索模块。
3. 在`Python`安装路径下的`Lib`目录下查找。
4. 使用`os.path`可以看到所有的查找路径。

### 模块的循环导入：

比如有现在目录中有两个模块，一个`a.py`，一个`b.py`。在`a.py`中引用了`b`。而在`b.py`中又引用了`a`，那么这时候就产生了循环导入，让两个导入都不能完成。

### `__name__`

如果是作为主程序来运行，那么等于`__main__`，如果是作为被导入的方式运行，那么是这个文件的名称。

### 安装包或者模块：

可以通过`pip`或者`easy_install`安装。`pip`是现代化的一种安装包的方式，以下讲解`pip`的常用命令：

1. 安装包：

   ```shell
       pip install requests
   ```

2. 安装指定版本的包：

   ```shell
    pip install django == 1.10.6
   ```

3. 卸载包：

   ```python
    pip uninstall django
   ```

4. 升级包：

   ```shell
    pip install -U requests
   ```

5. 升级`pip`：

   ```shell
    pip install -U pip
   ```

6. 查看当前`pip`是哪个版本：

   ```python
    pip --version
   ```

7. 显示某个已安装的包的信息：

   ```shell
    pip show -f <包名>
   ```

8. 列出当前环境下安装了哪些包：

   ```shell
    pip list
   ```

9. 将当前环境安装的包全部列出来放在文件中：

   ```shell
    pip freeze > requirements.txt
   ```

10. 从某个文件中安装包：

    ```shell
    pip install -r requirements.txt
    ```

11. 临时更改安装源，以豆瓣源为例：

    ```shell
    pip install <包名> -i https://pypi.douban.com/simple
    ```

12. 永久更改安装源：

    - windows操作系统：在当前用户目录下新建`pip/pip.ini`，然后在文件中添加以下代码：

      ```python
        [global]
        index-url = https://pypi.douban.com/simple
      ```

    - Linux/Mac：在用户目录下新建`.pip/pip.conf`，然后在文件中添加以下代码：

      ```ini
        [global]
        index-url = https://pypi.douban.com/simple
      ```